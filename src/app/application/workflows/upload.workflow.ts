import "reflect-metadata"  // used by DI (dependency injection)
import { inject, injectable } from "tsyringe"
import { Effect as E, Option as O, pipe, Schema as S } from "effect"
import crypto from "crypto"

import { InitiateUploadDTOSchema, InitiateUploadDTOEncoded } from "@/app/application/dtos/upload/initiate-upload.dto"
import { ConfirmUploadDTOSchema, ConfirmUploadDTOEncoded } from "@/app/application/dtos/upload/confirm-upload.dto"
import { UploadDocumentDTOSchema, UploadDocumentDTOEncoded } from "@/app/application/dtos/upload/upload-document.dto"

import { DocumentVersionRepository } from "@/app/domain/d-version/repository"
import { DocumentVersionEntity } from "@/app/domain/d-version/entity"
import { DocumentVersionAlreadyExistsError } from "@/app/domain/d-version/errors"
import { DocumentRepository } from "@/app/domain/document/repository"
import { TOKENS } from "@/app/infrastructure/di/tokens"
import { StorageServiceFactory } from "@/app/infrastructure/storage/storage.factory"

import { AccessControlService } from "@/app/application/services/access-control.service"
import { AuditLoggerService } from "@/app/application/services/audit-logger.service"

import { UserContext } from "@/presentation/http/orpc/auth"
import { withTiming } from "@/app/application/utils/timed-logger" 
import { DocumentVersionBuilder } from "@/app/application/dtos/upload/document-version.builder"
import { DocumentSchemaEntity } from "@/app/domain/document/entity"
import { withAppErrorBoundary } from "@/app/application/utils/application-error"

@injectable()
export class UploadWorkflow {
  constructor(
    @inject(TOKENS.DOCUMENT_REPOSITORY)
    private readonly documentRepo: DocumentRepository,

    @inject(TOKENS.DOCUMENT_VERSION_REPOSITORY)
    private readonly versionRepo: DocumentVersionRepository,

    @inject(TOKENS.STORAGE_SERVICE)
    private readonly storage: StorageServiceFactory,

    @inject(TOKENS.ACCESS_CONTROL_SERVICE)
    private readonly accessControl: AccessControlService,

    @inject(TOKENS.AUDIT_LOGGER_SERVICE)
    private readonly auditLogger: AuditLoggerService
  ) {}

  /**
   * Initiate Upload - returns a presigned URL
   */
  initiateUpload(
    input: InitiateUploadDTOEncoded,
    user: UserContext
  ) {
    return withTiming("Upload:initiateUpload", {
      correlationId: user.correlationId,
      userId: user.userId,
      workspaceId: user.workspaceId,
    }, async () => {
      const eff = E.gen(function* (this: UploadWorkflow) {
        // validate input against schema
        const dto = yield* S.decodeUnknown(InitiateUploadDTOSchema)(input)
        
        // Fetch document to check ownership
        const docOpt = yield* this.documentRepo.findById(dto.documentId)
        if (O.isNone(docOpt)) {
          return yield* E.fail(new Error(`Document ${String(dto.documentId)} not found`))
        }
        
        const doc = docOpt.value
        
        // require permission for upload on document resource 
        yield* this.accessControl.requirePermission(user, "document", "upload", {
          resourceOwnerId: doc.ownerId
        })
        
        // create presigned URL for the file
        // initialUpload returns a presigned URL generated by the storage service  
        // that the client can use to upload the file to the storage
        const url = yield* E.promise(() =>
          StorageServiceFactory.getInstance().createPresignedUrl(
            // unique storage key for the file (documentId/filename)
            // this is the path where the file will be stored in the storage 
            `${dto.documentId}/${dto.filename}`,
            dto.mimeType
          )
        )
        return url
      }.bind(this))
      return withAppErrorBoundary(eff)
    })
  }

  /**
   * Confirm Upload - persist uploaded file as document version
   */
  confirmUpload(
    input: ConfirmUploadDTOEncoded,
    user: UserContext
  ) {
    return withTiming("Upload:confirmUpload", {
      correlationId: user.correlationId,
      userId: user.userId,
      workspaceId: user.workspaceId,
    }, async () => {
      // Linear control flow using Effect.gen and the builder
      const eff = E.gen(function* (this: UploadWorkflow) {
        const dto = yield* S.decodeUnknown(ConfirmUploadDTOSchema)(input)

        // Ensure document exists
        const docOpt = yield* this.documentRepo.findById(dto.documentId)
        if (O.isNone(docOpt)) {
          return yield* E.fail(new Error(`Document ${String(dto.documentId)} not found`))
        }

        const doc = docOpt.value

        // Authorization - check if user is the owner
        yield* this.accessControl.requirePermission(user, "document", "upload", {
          resourceOwnerId: doc.ownerId
        })

        // De-dup by checksum
        const existing = yield* this.versionRepo.fetchByChecksum(dto.checksum as string)
        if (O.isSome(existing)) {
          return yield* E.fail(
            DocumentVersionAlreadyExistsError.forField("checksum", dto.checksum)
          )
        }

        // Compute next version number
        const nextVersion = yield* this.versionRepo.getNextVersionNumber(dto.documentId)

        // Build and persist version (the version entity is created and saved here) 
        const versionEntity = yield* new DocumentVersionBuilder()
          .setFromConfirmDTO(dto as any)
          .setVersion(nextVersion)
          .buildEntity()
        const savedVersion = yield* this.versionRepo.save(versionEntity)

        // Update document currentVersionId atomically in this flow
        const serializedDoc = yield* doc.serialized()
        const updatedDoc = yield* DocumentSchemaEntity.create({
          ...serializedDoc,
          currentVersionId: savedVersion.id,
          updatedAt: new Date().toISOString()
        })
        yield* this.documentRepo.save(updatedDoc)

        // Audit
        yield* this.auditLogger.logDocumentOperation(
          "document_version_created",
          savedVersion.documentId,
          "upload",
          user,
          "success",
          { versionId: savedVersion.id }
        )

        return savedVersion
      }.bind(this))
      return withAppErrorBoundary(eff)
    })
  }

  /**
   * Upload File - direct file upload (native File/Blob support)
   * Combines initiate + confirm into a single operation
   */
  uploadFile(
    input: UploadDocumentDTOEncoded & { file: File },
    user: UserContext
  ) {
    return withTiming("Upload:uploadFile", {
      correlationId: user.correlationId,
      userId: user.userId,
      workspaceId: user.workspaceId,
    }, async () => {
      const eff = E.gen(function* (this: UploadWorkflow) {
        const dto = yield* S.decodeUnknown(UploadDocumentDTOSchema)(input)
        const file = input.file

        // Ensure document exists
        const docOpt = yield* this.documentRepo.findById(dto.documentId)
        if (O.isNone(docOpt)) {
          return yield* E.fail(new Error(`Document ${String(dto.documentId)} not found`))
        }

        const doc = docOpt.value

        // Authorization - check if user is the owner
        yield* this.accessControl.requirePermission(user, "document", "upload", {
          resourceOwnerId: doc.ownerId
        })

        // Convert File to Buffer and FileUpload interface
        const arrayBuffer = yield* E.promise(() => file.arrayBuffer())
        const buffer = Buffer.from(arrayBuffer)
        const mimeType = file.type || "application/octet-stream"
        const fileSize = file.size

        // Calculate checksum
        const checksum = yield* E.promise(() => {
          return new Promise<string>((resolve) => {
            const hash = crypto.createHash("sha256")
            hash.update(buffer)
            resolve(hash.digest("hex"))
          })
        })

        // De-dup by checksum
        const existing = yield* this.versionRepo.fetchByChecksum(checksum)
        if (O.isSome(existing)) {
          return yield* E.fail(
            DocumentVersionAlreadyExistsError.forField("checksum", checksum)
          )
        }

        // Compute next version number
        const nextVersion = yield* this.versionRepo.getNextVersionNumber(dto.documentId)

        // Upload file to storage
        const storageKey = `${dto.documentId}/${file.name}`
        const uploadResult = yield* E.promise(() =>
          StorageServiceFactory.getInstance().uploadFile(
            {
              buffer, originalname: file.name, mimetype: mimeType, size: fileSize,
            },storageKey,
            {contentType: mimeType,}
          )
        )

        // Build and persist version entity
        const versionData = {
          documentId: dto.documentId,
          filename: file.name,
          mimeType,
          size: fileSize,
          storageKey: uploadResult.key,
          checksum,
          uploadedBy: dto.userId,
        }

        const versionEntity = yield* new DocumentVersionBuilder()
          .setFromUploadData(versionData as any)
          .setVersion(nextVersion)
          .buildEntity()
        const savedVersion = yield* this.versionRepo.save(versionEntity)

        // Update document currentVersionId atomically
        const serializedDoc = yield* doc.serialized()
        const updatedDoc = yield* DocumentSchemaEntity.create({
          ...serializedDoc,
          currentVersionId: savedVersion.id,
          updatedAt: new Date().toISOString()
        })
        yield* this.documentRepo.save(updatedDoc)

        // Audit
        yield* this.auditLogger.logDocumentOperation(
          "document_version_created",
          savedVersion.documentId,
          "upload",
          user,
          "success",
          { versionId: savedVersion.id }
        )

        return savedVersion
      }.bind(this))
      return withAppErrorBoundary(eff)
    })
  }
}
